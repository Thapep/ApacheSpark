Ερώτημα Q1: Ουσιαστικά εδω πέρα θα δώσουμε σαν εισοδο στην διαδικασία map μια γραμμή του csv, η οποία στη συνέχεια θα δώσει σαν έξοδο μια τούπλα της οποίας το πρώτο στοιχείο θα είναι η χρονιά ώστε να ομαδοποιηθούν στα στοιχεία ανά χρονιά, και το δευτερο στοιχείο θα είναι μια τούπλα με το όνομα της ταινίας και το κέρδος σύμφωνα με τον oρισμό που μας εχει δωθεί. Τέλος, η διαδικασία reduceByKey θα ομαδοποιήσει τις ταινιες ανα χρονιά και θα εξάγει την ταινία με το μέγιστο κέρδος. 

Με βάση αυτά οδηγούμαστε στον παρακάτω ψευδοκωδικα

```
map(line):
	year = line[3]
	name = line[1]
	profit = (line[6]-line[5])/line[5]*100
	emit (year, (name, profit))
	
reduce(year, list_of_name_profit):
	max = findmax(list_of_name_profit)		
	emit (year, max)    
```



Σημείωση: Η συνάρτηση findmax παίρνει σαν είσοδο τη λιστα με τις τουπλες, βρίσκει την τουπλα που περιέχει το μέγιστο κέρδος και την επιστρέφει. Δηλαδή, η έξοδος μας είναι της μορφής (year, (name, profit)) ώστε να βολεύει στη συνέχεια να χρησιμοποιήσουμε τη συνάρτηση sortByKey για να ταξινομήσουμε την έξοδο με βάση το έτος.



Ερώτημα Q2: Εδώ θα χρειαστούμε τρεις διαδικασίες map-reduce. Η πρώτη map, θα πάρει σαν ειδοσο ενα line του csv και θα εξαγει ανα χρήστη την βαθμολογία του και εναν ασσο ενώ το reduce θα πάρει ανα χρήστη μια λίστα με βαθμολογίες και τους ασσους και θα υπολογίσει τον συνολικό αριθμό των βαθμολογιών καθώς και το πλήθος τους. Η δεύτερη map-reduce χρησιμεύει στην ομαδοποίηση των δεδομένων. Συγκεκριμένα, για κάθε χρήστη κοιτάει τη μέση βαθμολογία και αν ειναι κατω από 3 του δείνει id = 1 ενω σε αντίθετη περίπτωση, id=2. Έτσι, καταλήγουμε σε ενα dataset με δύο τουπλες: (1, πληθος1) και (2, πληθος2). Τέλος, η τρίτη και τελευταία map-reduce χρησιμεύει ώστε να έχουμε κατω από το ίδιο id τις δύο μεταβλητές ώστε να υπολογίσουμε το τελικό ποσοστό.

Παρακάτω φαίνεται ο ψευδοκώδικας

```
map1(line):
	user = line[0]
	rating = line[2]
	emit(user, (rating,1))
	
reduce1(user, list_of_ratings_aces):
	r = 0
	c = 0
	for x, y in list_of_ratings_aces:
		r += x
		c += y
	average = r/c
    emit(user,average)
    
map2(user,average):
	if average < 3: return (1,1)
	else return (2,1)

reduce2(id,list_of_aces):
	c = len(list_of_aces)
	emit(id,c)
	
map3(id,c):
	emit(1,c)

reduce3(1,list_of_c):
	c1 = list_of_c[0]
	c2 = list_of_c[1]
	per = c2/(c1+c2)*100
	emit(per)
```



***Σημείωση***: Στην reduce3 υποθέτουμε πως στην πρώτη θέση είναι το πληθος όσων έχουν μέση βαθμολογία κάτω από 3.